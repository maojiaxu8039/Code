#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2017/3/17 15:51
# @Author  : maojx
# @Site    :
# @File    : 正则表达式.py
# @Software: PyCharm
import re

"""
用\d可以匹配一个数字，\w可以匹配一个字母或数字
要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：
要做更精确地匹配，可以用[]表示范围
A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
^表示行的开头，^\d表示必须以数字开头。
$表示行的结束，\d$表示必须以数字结束。
"""

# re 模块
# 由于Python的字符串本身也用\转义，所以要特别注意
s = 'ABC\\-001'
# 因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了
s = r'ABC\-001'

# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')

# 切分字符串
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))

# 分组
# 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：
# ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
m.group(0)  # group(0)永远是原始字符串
m.group(1)
m.group(2)

# 贪婪匹配
# 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0
re.match(r'^(\d+)(0*)$', '102300').groups()
# 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
# 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：
re.match(r'^(\d+?)(0*)$', '102300').groups()
