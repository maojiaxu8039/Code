#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2017/3/17 16:49
# @Author  : maojx
# @Site    : 
# @File    : 生成器.py
# @Software: PyCharm
"""
生成器内部基于yield创建，即：对于生成器只有使用时才创建，从而不避免内存浪费
生成器函数在Python中与迭代器协议的概念联系在一起。简而言之，包含yield语句的函数会被特地编译成生成器。当函数被调用时，他们返回一个生成器对象，这个对象支持迭代器接口。函数也许会有个return语句，但它的作用是用来yield产生值的。
不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效
"""
"""
首先请确信，生成器就是一种迭代器。生成器拥有next方法并且行为与迭代器完全相同，这意味着生成器也可以用于Python的for循环中。另外，对于生成器的特殊语法支持使得编写一个生成器比自定义一个常规的迭代器要简单不少，所以生成器也是最常用到的特性之一。
获取一个生成器
def get_0_1_2();
    yield 0
    yield 1
    yield 2
我们定义了一个函数get_0_1_2，并且可以查看到这确实是函数类型。但与一般的函数不同的是，get_0_1_2的函数体内使用了关键字yield，这使得get_0_1_2成为了一个生成器函数。生成器函数的特性如下：
第一次调用生成器的next方法时，生成器才开始执行生成器函数（而不是构建生成器时），直到遇到yield时暂停执行（挂起），并且yield的参数将作为此次next方法的返回值；
generator.next()
之后每次调用生成器的next方法，生成器将从上次暂停执行的位置恢复执行生成器函数，直到再次遇到yield时暂停，并且同样的，yield的参数将作为next方法的返回值；
如果当调用next方法时生成器函数结束（遇到空的return语句或是到达函数体末尾），则这次next方法的调用将抛出StopIteration异常（即for循环的终止条件）；
生成器函数在每次暂停执行时，函数体内的所有变量都将被封存(freeze)在生成器中，并将在恢复执行时还原，并且类似于闭包，即使是同一个生成器函数返回的生成器，封存的变量也是互相独立的。
"""

